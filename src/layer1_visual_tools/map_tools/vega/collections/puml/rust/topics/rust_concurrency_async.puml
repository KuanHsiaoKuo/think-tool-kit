@startmindmap
* 并发异步
** 区别并发异步
*** 并发指多个任务同时（并行）运行，异步指单个任务以非阻塞的方式进行
** 并发
*** 并发原语（并发模型）
**** 自由竞争
***** Atomic：原子类型，在多线程环境中对内存进行原子级别处理，保证数据的正确性
***** Mutex：互斥锁，通过加锁操作限制同时访问某个数据的线程数，以保证数据的正确性
**** 限制顺序
***** map：将线程任务分派到多个计算资源上执行，实现任务并行
***** reduce：将多个线程的计算结果合并，达到最终目标的效果
**** 限制依赖
***** DAG：减小资源浪费，提高并行效率，实现对任务的并行化
***** Condvar：条件变量，通过wait和signal的操作，实现线程的等待和唤醒，以保证数据的正确性
***** Channel：管道机制，用于线程间通信，以保证数据准确传递
***** Actor：以Actor模型的思想，将数据和行为封装在一起，不依赖共享状态，实现对并发下数据的保护与处理
*** 实现方式
**** 多进程：多个进程之间可以通过IPC（如Pipe、Socket等）实现通信和数据的共享
**** 多线程：多线程之间可以共享进程中的资源（如变量、内存等），通过锁或原子操作实现线程同步
**** 异步：采用异步编程模型处理并发，使用事件循环机制实现非阻塞IO
***** Future：以回调函数为基础的异步编程模型，实现了对回调函数的封装和优化
** 异步
*** Actor
**** 有栈协程：采用基于“半同步/半异步”模型的Green Thread，实现对Actor执行状态的保存和传输
**** Task：负责调度和执行Future，通过Futures-compatible RFC 1983规范的接口实现对Future的异步执行
***** Task管理：用于管理Future的执行状态，操作包括启动、暂停、取消等
***** 状态同步：实现对Future执行状态的同步
*** Future
**** 无栈协程：使用基于状态机的实现方式，将Future整个执行过程分解为多个状态，实现对Future执行状态的保存和传输
***** 状态机实现：采用状态机设计模式，实现状态和状态之间的更迭操作
***** 等待实现：通过调用poll方法，实现等待某个事件发生并返回结果
***** yield实现：通过执行yield操作，实现Future执行过程的暂停和恢复
**** 深入Future
***** Poll：实现对Future执行状态的更新和传递
***** Future Trait：以Trait的形式封装Future，实现对Future的复用和扩展
***** Pin：防止修改Future的内存地址，保证Future在执行过程中内存地址不变
***** Unpin：实现Future对内存生命周期的控制，保证Future数据的有效性
**** async/await联动
***** async/await：以关键字的形式实现对Future代码的简化
***** Future Trait：实现对Future的扩展和抽象化
@endmindmap